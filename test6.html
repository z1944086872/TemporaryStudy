<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 最大乘积连续子串
//         function maxProduct( nums ) {
//             let maxEnd;
//             let minEnd;
//     let maxResult=nums.reduce(function(pre,arr,index){
//         if(index==0){
//             maxEnd=arr;
//             minEnd=arr;
//             return maxEnd;
//         }
//         maxEnd=Math.max(Math.max(maxEnd*arr,arr));
//         minEnd=Math.min(Math.min(maxEnd*arr,arr));
//         return Math.max(pre,maxEnd);

//     },0);
//     return maxResult;
    
    
// }
// let nums= [2,3,-4,2];
// console.log(maxProduct(nums));

// 快排
// let arr=[3,6,1,-4,6,5];
// function quickSort(arr){
//     if(arr.length<=1) return arr;
//     var pivotIndex=Math.floor(arr.length/2);
//     var pivot=arr.splice(pivotIndex-1,1)[0];
//     var left=[];
//     var rigth=[];
//     for(var i=0;i<arr.length;i++){
//         if(arr[i]<pivot){
//             left.push(arr[i]);
//         }else{
//             rigth.push(arr[i]);
//         }
//     }

//     return quickSort(left).concat([pivot],quickSort(rigth));

// }
// console.log(quickSort(arr));
// 括号匹配
// 
// 树
// class TreeNode{
//     constructor(value){
//         this.value=value;
//         this.left=null;
//         this.right=null;
//     }

// }
// let root =new TreeNode(1);
// root.left=new TreeNode(2);

// 反转单链表
// function reverseList(head){
//     if(!head||!head.next) return head;
//     let cur=head;
//     let pre=null;
//     while(cur){
//         var next =cur.next;
//         cur.next=pre;
//         pre=cur;
//         cur=next;

//     }
//     head=pre;
//     return head;

// }
// class List1{
//     constructor(value){
//         this.value=value;
//         this.next=null;

//     }
// }
// let head=new List1(1);
// head.next=new List1(2);
// head.next.next=new List1(3);

// // let head2=reverseList(head);
// let curr=head;

// while(curr){
//     console.log(curr.value);
//     curr=curr.next;
// }
// 动态规划
// function rob(nums){
//     if(!nums||nums.length===0) return 0;
//     if(nums.length<3) return Math.max(...nums);
//     let dp=[];
//     dp[0]=nums[0];
//     dp[1]=Math.max(nums[0],nums[1]);
//     for(let i=2;i<nums.length;i++){
//         dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1]);
//     }
//     return dp[nums.length-1];
// }
// let nums=[2,7,9,3,1] ;
// console.log(rob(nums));



    </script>
</body>
</html>